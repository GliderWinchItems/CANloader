/******************************************************************************
* File Name          : crc-srec.c
* Date First Issued  : 09/02/2022
* Board              : Linux PC
* Description        : Add CRC-32 to end of .srec file
*******************************************************************************/
/*
gcc -Wall crc-srec.c crc-32_nib.c -o crc-srec 
gcc -Wall crc-srec.c crc-32_nib.c -o crc-srec && ./crc-srec ../../ldrfixedL431/build/ldrfixedL431

*/

#include <stdio.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include <time.h>
#include <stdint.h>
#include <stdlib.h>

#include "crc-32_nib.h"


#define LINESZ 128 // Max srec line size
char buf[LINESZ];
char bufsav[LINESZ];

FILE* fpIn;    // srec input file
FILE* fpBin;   // bin input file
FILE* fpS3out; // srec modified output file
FILE* fpCrc;   // CRC (hex ascii)

// Our binary image
uint8_t   bin[1024*1024];
uint8_t* pbin;

// Binary from srec line
struct S3BIN
{
	uint32_t addr;
	uint8_t data[LINESZ];
	uint8_t checksum;
	uint8_t ct;
}s3bin;

uint8_t hexbin(char* p);
uint8_t s3cnvt(struct S3BIN* po, char* pi);

// Some counters for debugging
	int linect;
	int s3ct;
	int bct;
	int linelen;

// CRC 
uint32_t crc;	

// Checksum on binary file
uint64_t binchksum;

// Additonal S3 rec
uint8_t bintmp[32];
char rectmp[64];
uint8_t chktmp;
const char tbl[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};

//char *canid_insert = "w";

/* ************************************************************************************************************ */
/*  Yes, this is where it starts.                                                                               */
/* ************************************************************************************************************ */
int main(int argc, char **argv)
{
	int i;
	char ain[64];
	char abin[64];
	char as3out[64];
	char acrc[64];
	uint8_t oe;

   /* **********************************************************************************  */
   /* Open files with same name but different extensions                                  */
   /* **********************************************************************************  */
	// .srec generated by compiler
	strncpy (ain,*(argv+1),56);
	strcat (ain,".srec");
	if ( (fpIn = fopen (ain,"r")) == NULL)
	{
		printf ("\nInput .srec file did not open:      %s\n",ain);
		exit (-1);
	}
	printf(".srec file opened read:        %s\n",ain);

	// .bin generated by compiler
	strncpy (abin,*(argv+1),56);
	strcat (abin,".bin");
	if ( (fpBin = fopen (abin,"rb")) == NULL)
	{
		printf ("\nInput .bin file did not open:  %s\n",abin);
		exit (-1);
	}	
	printf(".bin file opened read binary:  %s\n",abin);

	// Modified .srec generated by this program
	strncpy (as3out,*(argv+1),56);
	strcat (as3out,".srec-crc");
	if ( (fpS3out = fopen (as3out,"w")) == NULL)
	{
		printf ("\nOutput .srec-crc file did not open: %s\n",as3out);
		exit (-1);
	}	
	printf(".srec-crc file opened write:   %s\n",as3out);

	// CRC (ascii hex) generated by this program
	strncpy (acrc,*(argv+1),56);
	strcat (acrc,".crc");
	if ( (fpCrc = fopen (acrc,"w")) == NULL)
	{
		printf ("\nOutput .crc file did not open: %s\n",acrc);
		exit (-1);
	}		
	printf(".crc file opened write binary: %s\n",acrc);

// S3150800000000C00020E54900086D0A0008710A0008CA	

	linect = 0; // Line counter
	s3ct = 0;
	pbin = &bin[0];
	crc = ~0L;     // Initial CRC value
	binchksum = 0; // Checksum
	oe = 0; // Odd even
	while ( (fgets (&buf[0],LINESZ,fpIn)) != 0)	// Get a line
	{
		linect += 1;
		linelen = strlen(buf);
		if (linelen < 6) exit(-2);//continue;
//printf("%s",buf);
		if (buf[0] != 'S') continue;
		if (buf[1] == '3')
		{ // Here an S3 line
			s3ct += 1;
			bct = hexbin(&buf[2]);
			if ((bct < 5) || (bct > 128))
			{
				printf("S3 byte ct bad: %d %c%c on line %d\n\r",bct,buf[2],buf[3],linect);
				exit(-3);
			}
			else
			{
				// Convert S3 line to binary
				s3cnvt(&s3bin, buf);
				// Save binary, accum CRC, build checksum (words)
				for (i=0; i < s3bin.ct; i++)
				{ 
					*pbin++ = s3bin.data[i]; // Our bin data
					// Accumulate CRC
					crc = crc_32_nib_acc(crc,s3bin.data[i] ); 
					// Build checksum by words, not bytes
					if (oe == 0)
					{ // Here byte is even
						binchksum += s3bin.data[i];
					}
					else
					{ // Here byte is odd
						binchksum += (s3bin.data[i] << 8);
					}
					oe ^= 1;
				}
 //printf("%4d %s",bct, buf);
				strncpy(bufsav,buf,LINESZ);
				fprintf(fpS3out,"%s",buf);
			}			
		}
		if (buf[1] == '0')
		{
			fprintf(fpS3out,"%s",buf);
		}

	}

	// Wrap 64b sum into 32b word
	binchksum += (binchksum >> 32);
	binchksum &= 0xffffffff;
	binchksum += (binchksum >> 32);
	binchksum &= 0xffffffff;

	printf("last srec3: %s",bufsav);

	// Check out bin data against compiler generated bin data
	int binfilectr = 0;
	uint32_t idx=0;
	uint8_t bb;
	uint32_t zct = 0;
	while ( (fread (&bb,sizeof(bb),1,fpBin)) != 0)	// Get a byte
	{
		binfilectr += 1;
		if ((bin[idx++] != bb) && (zct++ < 10))
		{
			printf("%6u %02X %02X\n\r",binfilectr,bin[idx],bb);
		}

	}

	/* Generate a S3 rec to store the CRC and checksum */
	// Set load address
	printf("last compile S3 cnt  : %d %X\n\r",s3bin.ct,s3bin.ct);
	printf("last compile S3 addr : 0x%08X\n\r",s3bin.addr);
	s3bin.addr += s3bin.ct;
	printf("Inserted S3 load addr: 0x%08X\n\r",s3bin.addr);
	// Set up bin array
	bintmp[ 0] = 13;
	bintmp[ 1] = s3bin.addr >> 24;
	bintmp[ 2] = s3bin.addr >> 16;
	bintmp[ 3] = s3bin.addr >>  8;
	bintmp[ 4] = s3bin.addr >>  0;
	bintmp[ 5] = crc >>  0;
	bintmp[ 6] = crc >>  8;
	bintmp[ 7] = crc >> 16;
	bintmp[ 8] = crc >> 24;
	bintmp[ 9] = binchksum >>  0;
	bintmp[10] = binchksum >>  8;
	bintmp[11] = binchksum >> 16;
	bintmp[12] = binchksum >> 24;
	char* pr = &rectmp[0];
	*pr++ = 'S';
	*pr++ = '3';
	chktmp = 0;
	for (i = 0; i < 13; i++)
	{
		chktmp += bintmp[i];
		*pr++ = tbl[bintmp[i] >> 4];
		*pr++ = tbl[bintmp[i] & 0x0F];
	}
	chktmp ^= 0xFF;
	*pr++ = tbl[chktmp >> 4];
	*pr++ = tbl[chktmp & 0x0F];
	*pr++ = '\n';
	*pr++ = 0;

	printf ("Inserted S3 line: %s",rectmp);

	printf("bintmp:         ");
	for (i = 0; i < 13; i++)
	{
		printf(" %02X",bintmp[i]);
	}
	printf(" : %02X\n",chktmp);

	s3cnvt(&s3bin, rectmp);
	printf("Inserted replay: %2d %08X : ",s3bin.ct, s3bin.addr);
	for (i = 0; i < s3bin.ct; i++)
	{
		printf(" %02X",s3bin.data[i]);
	}
	printf(" : %02X\n\r",s3bin.checksum);

	fprintf(fpS3out,"%s",rectmp);
	fprintf(fpS3out,"%s",buf);

	printf ("CRC generated : 0x%08X\n\r",crc);
	printf ("Checksum gen  : 0x%08lX\n\r",binchksum);
	printf ("Total line ct : %5d\n\r",linect);
	printf ("Size of bin   : %5d\n\r",(int)(pbin-&bin[0]));
	printf ("Size bin file : %5d\n\r",(int)(binfilectr));

	fclose(fpIn);
	fclose(fpBin);
	fclose(fpS3out);
	fclose(fpCrc);
	exit(0);
}
/* ********************************************************************************** 
* uint8_t hexbin(char* p);
* @brief    : Convert two hex chars to a binary byte
* @param	: p = pointer to hex char
* @return   : binary value 
* **********************************************************************************  */
uint8_t hexbin_nib(char *p)
{
	if (*p <= '9')
	{
		return *p - '0';
	}
	if (*p < 'a')
		{
			return *p - 'A' + 10;
		}
	return *p - 'a' + 10;
}

uint8_t hexbin(char* p)
{
	return (hexbin_nib(p) << 4) + hexbin_nib(p+1);
}
/* ********************************************************************************** 
* uint8_t s3cnvt(struct S3BIN* po, char* pi);
* @brief    : Convert S3 into binary with checksum check
* @param	: pi = pointer to S3 buffer hex line
* @param    " po = pointer to struct with binary
* @return   : 0 = OK; not 0 = failed
* **********************************************************************************  */
uint8_t s3cnvt(struct S3BIN* po, char* pi)
{
	uint8_t i;
	uint8_t ct = hexbin((pi+2));

	po->ct = ct - 5;
	po->checksum = 0x00;

	// 0000000000111111111122222222223333333333444444
    // 0123456789012345678901234567890123456789012345  
	// S3150800000000C00020E54900086D0A0008710A0008CA
/*	
0000000000111111111122222222223333333333444444
0123456789012345678901234567890123456789012345  
S31508005E3847455420464C41534850206164647220B3 */
	po->addr  = hexbin((pi + 4)) << 24;
	po->addr |= hexbin((pi + 6)) << 16;
	po->addr |= hexbin((pi + 8)) <<  8;
	po->addr |= hexbin((pi +10)) <<  0;

	po->checksum += hexbin((pi + 2));
	po->checksum += hexbin((pi + 4));
	po->checksum += hexbin((pi + 6));
	po->checksum += hexbin((pi + 8));
	po->checksum += hexbin((pi +10));

//printf("%08X : ",po->addr);

	for (i = 0; i < ct-5; i++)
	{
		po->data[i] = hexbin((pi+12+2*i));
		po->checksum += po->data[i];
//printf(" %02X", po->data[i]);	
	}
	po->checksum ^= 0xff;
	uint8_t check = hexbin((pi+12+2*i));
//printf(" : %02X %02X\n\r",po->checksum,check);
	if (check != po->checksum)
	{
		printf("BAD CHECK:%02X %02X at line: %d\n\r",po->checksum,check,linect);
		return 1;
	}
	return 0;
}
